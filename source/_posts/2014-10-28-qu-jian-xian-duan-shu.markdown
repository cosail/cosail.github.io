---
layout: post
title: "线段(区间)树"
date: 2014-10-28 19:53:48 +0800
comments: true
categories: datastruct-tree
---

**线段树**是一棵二叉树，其每一个节点表示了一个区间[a, b]；每一层中所有节点表示的区间互不重叠，其并都为整个区间范围。

<font color='blue'>特点：</font> 每一个叶子节点表示一个不可再分的单位区间；若一个非叶子节点表是区间[a, b]，则其左子节点表示[a, (a+b)/2]，右子节点表示((a+b)/2，b]。  
其实是进行了二分，所以线段树是一棵平衡树，其深度不超过 lg(L)，L为最长区间长度。

<font color='blue'>应用：</font> 线段树适合用来处理有关区间统计的问题：按区间划分，修改，特别是需要经常进行查找操作时。

<font color='red'>题1：</font> 求序列 a1a2...an 的任意一个子序列 ai...aj 的和，同时允许动态修改每个元素的值？  
<font color='green'>解：</font> 构造一棵区间树，其根节点表示区间[a1, an]，每个节点里再加上额外字段 sum 来表示区间里所有数的和。  
对于求子序列和：找到子序列覆盖的所有子区间，把这些子区间对应的 sum 累加。那怎么去累加呢？一是用递归；二是遍历这段被覆盖的区域。  
对于修改元素值：与区间两端值作比较，往下找到元素所在的节点；然后修改元素值；最后往上更新每个节点的 sum 值，直到根节点。

<font color='red'>变形：</font> 求序列 a1a2...an 的任意一个子序列 ai...aj 的和，同时允许对某个子序列中所有元素的值都增加 k？  
<font color='green'>解：</font> 若像题1一样逐个修改元素值，则工作量有点大。若这种操作很经常的话，可以在为每个节点加一个额外字段 inc 来表示该节点对应区间中每个值的增量。求和时只需加上 inc * 区间元素个数。当然，查找元素时别忘了带着增量往下走。

<font color='red'>题2：</font> 求序列 a1a2...an 的任意一个子序列 ai...aj 中最大元素与最小元素值的差？  
<font color='green'>解：</font> 类似题1，每个节点里再加上两个额外字段 min,max 来表示区间里最小元素值，最大元素值。  
找到子序列覆盖的所有子区间，从这些子区间中找出最大值和最小值，再相减。  

<font color='red'>题3：</font> 苹果树。一棵苹果树上每个分叉点（二叉）及末梢可能有苹果(最多1个)，每次可以摘掉一个苹果，或有一个苹果新长出来，随时查询某块树枝（某个分叉点往上的子树）上，一共有多少个苹果。  
<font color='green'>解：</font> 该题关键要看到，每个非叶子节点上也是会长苹果的。深度优先遍历整个苹果树，为每个节点标记一个序号（1~n），一个值为 0 或 1 的 apple 字段（可变化），一个 sum 字段。某个节点往上对应树枝上的苹果数即该节点里的 apple + sum 值。







